### 智能指针 
#### 与普通引用的区别
1. 提供了额外的功能
2. 只是表现得像引用，多数情况下，拥有数据所有权

- String和Vec<T>也是智能指针; Vec<T> -> &[T]; String -> &str
- 智能指针通常用结构体实现，并实现了Deref和Drop特征


#### Box<T>
- 可以创建递归类型
```rust
enum List {
    // Box可以创建固定大小类型，否则编译会报错
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}

```
- 可以创建特征对象


#### deref特征
- 允许我们重载解引用运算符 ”*“
- 智能指针解引用运算符的本质：*(x.deref())
- 解引用不会自动递归，多次解引用必须：“**x”
- 函数/方法参数自动解引用
    - 必须传入&T
    - 可依自动递归，例子：
        ```rust
        fn main() {
            let ss = Box::new(String::from("d"));
            test(&ss);
        }

        fn test(a: &str) {}
        ```

- Deref 强制转换如何与可变性交互
    - 当 T: Deref<Target=U> 时从 &T 到 &U。
    - 当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U。
    - 当 T: Deref<Target=U> 时从 &mut T 到 &U。


#### drop特征
- 智能指针通常会实现drop特征（其他类型也可以实现）
- 当一个变量go out of scope（或者提前调用std::mem::drop方法），会自动执行drop方法（编译器帮我们插入代码）
- 变量执行drop的顺序与创建的顺序相反，可能和栈的先入后出特性有关？？
- 可以在drop方法内释放资源，如堆内存，实现自动释放堆内存的目的


#### Rc<T>
- 多所有权，允许多个变量同时拥有同一个值（堆内存）
- 通过clone方法创建一个新的Rc，并将引用计数+1
- 当Rc变量执行drop方法，引用计数-1
- 当值当引用计数变为0时，自动释放堆内存
- 只能使用值的不可变引用，否则会违反借用规则（如果要修改数据，需要结合RefCell使用 内部可变性）
- 只能用于单线程场景（引用计数修改没有使用并发原语）

#### RefCell<T> 内部可变性
- 它不是智能指针
- 允许不可变引用改变数据，内部采用unsafe实现
- 并没有违背借用规则，只是把借用检查推迟到运行时，如果违反（多个不可变引用同时存在）则程序会panic！
- 同Rc，只能用于单线程场景（运行时借用检查没有使用并发原语）
- 与Rc结合可以实现多个可变的拥有者

#### Box<T>，Rc<T> 或 RefCell<T>区别
- Rc<T> 允许相同数据有多个所有者；Box<T> 和 RefCell<T> 有单一所有者。
- Box<T> 允许在编译时执行不可变或可变借用检查；Rc<T>仅允许在编译时执行不可变借用检查；RefCell<T> 允许在运行时执行不可变或可变借用检查。
- 因为 RefCell<T> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<T> 自身是不可变的情况下修改其内部的值。

